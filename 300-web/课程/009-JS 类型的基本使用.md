---
title: 009-JS 类型的基本使用
date: 2023-02-28 17:07
updated: 2023-03-01 17:34
cover: //cdn.wallleap.cn/img/post/1.jpg
image-auto-upload: true
author: Luwang
comments: true
aliases:
  - 009-JS 类型的基本使用
rating: 1
tags:
  - JavaScript
category: web
keywords:
  - 关键词1
  - 关键词2
  - 关键词3
description: 文章描述
source: null
url: //myblog.wallleap.cn/post/1
---

## 数字和字符串

### 数字的日常用法

- `parseInt(string[, radix])`
	- 把第一个参数转换为字符串，并对字符串进行解析，返回一个整数或 `NaN`
	- 第一个参数是字符串，如果不是会先使用 `toString` 转为字符串，开头空白字符会被忽略
	- 第二个参数可选，是 `2` 到 `36` 的整数，表示进制的基数
	- 默认是返回一个十进制数，指定了进制的话（第二参数）那么会按照这个进制转换成十进制整数
	- 如果只有数字的话建议不加引号，其他进制数一样 如 `0o11`、`0b11`、`0x11`，写的这种形式会按照推断进行转换为十进制
	- 如果加了引号，只会识别前面的数字，后面的字母会截断，例如 `11x00` 返回 `11`，如果字母开头那输出 `NaN`
	- 第二个参数不指定或指定为 `0` 是自己推断，如果不是 `0` 或 `2` 到 `36` 的数会返回 `NaN`
- `parseFloat(string)`
	- 返回一个浮点数或 `NaN`
	- 如果参数对象里有 toString 或 valueOf 方法，会返回他们的返回值

```js
parseInt('100')  // 转为数字
parseInt('100', 2)  // 第二个参数是进制，以该进制转为十进制数输出
parseInt(15.20)  // 可以去除小数部分
parseInt('ab123')  // 不以数字开头，会输出 NaN
/* 二进制存储数字，所以小数的时候会出现精度问题 */
(0.1+0.2) !== 0.3  // 尽量不用浮点数 例如金额直接用最小单位188888分
parseFloat('3.45')  // 转为浮点数
34.5678.toFixed(2)  // 保留多少位小数（有四舍五入）
```

### 数字的深入了解

```js
num.toPrecision(5)  // 限制整数+小数的总位数
2**53 < 2**53+1  // 返回 false 超出最大范围了
Number.MAX_SAFE_INTEGER // 最大范围
Number.MAX_VALUE // 1.79e+308 最大值 加任意值不会变了
Number.MAX_VALUE * 2 // 乘2会返回 Infinity
// 可以使用大数 100n 本质是字符串运算
10000000000000000000n + 3658n
/* Math 方法 */
Math.abs(-111)  // 绝对值
Math.floor(3.55)  // 3 向下取整
Math.ceil(3.12)  // 4 向上取整
Math.round(1.5)  // 2 四舍五入取整
Math.random()  // 取[0,1)的随机值
Math.floor(Math.random()*100) // [0,100) 的整数
Math.floor(y + Math.random()*(x-y+1)) // [y,x] 的整数
Math.pow(x,y)
x**y  // x 的 y 次方
```

### 字符串表示

可以使用成对的引号包裹

- `'string'`
- `"hello"`

或者使用 "`" 符号包裹

```js
let str = `hello JavaScript`
```

使用 `\` 进行转义

```js
let path = "D:\\Games\\war"
let str1 = "你好啊，这个是 \"引号包裹的内容\" \n我是换行后的内容"
```

模板字符串中变量 `${变量}`

```js
let name = 'luwang', age = 25
console.log("Hello, my name is " + name + ", age " + age + ".") // 字符串拼接
console.log(`Hello, my name is ${name}, age ${age}.`) // 模板字符串
```

### 字符串的访问和拼接

```js
str.length  // 字符串长度
str[0]  // 下标获取字符 str[str.length - 1]
str.charAt(0)
str.charCodeAt(0)  // 获取到的字符的 Unicode 值
str1 + str2
`${str1}${str2}`
str1.concat(str2)
```

### 字符串的查找和截取

```js
str.indexOf('subStr')  // 返回的是数字  -1 代表没找到
str.lastIndexOf(subStr)  // 从后往前找
str.includes(subStr)  // 返回 Boolean false 是没找到
str.startsWith(subStr)
str.endsWith(subStr)
str.substr(1,3)  // 开始位置，和截取的长度
str.substring(1,3)  // 开始位置和结束位置  开头结尾 返回 Boolean
```

### 字符串其他操作

```js
str.split(' ')  // 以什么分开为数组
str.trim()  // 去除两边的空格
str.trimLeft()  // 去除左边的空格
str.toUpperCase()  // 转成大写
str.toLowerCase()  // 转成小写
```

## 数组基础使用

```js
// 定义
let arr = [2, [1, 3]
// 长度
arr.length
arr.length = 0  // 清空数组
// 访问
arr[0]
arr[arr.length -1]
arr[1][1]
arr[arr.length]  // 越界会返回 undefined
arr[arr.length] = 1 // 可以直接赋值  在末尾加1
```

## 对象基础使用

```js
// 定义
// 无序的数据集合，由若干个“键值对”构成
let obj = { str: 'hello', num: 12}
console.log(obj)
// 访问
obj.str
obj['str']
let key = 'str'
obj[key] // 可以给变量 就不用加引号了（变量只能用方括号，不能用点访问对象属性）
obj['key']  // 没有会返回 undefined
obj.bool  // 不存在的属性 undefined
// 可以直接修改属性
obj.num = 18
```

## 流程控制语句

### 条件判断语句

#### if 语句

```js
/* 判断 */
if(条件) { /* 条件满足进入 */
  // 语句
}
/* if...else */
if(条件) { /* 满足条件进入 */
  // 语句
} else { /* 不满足条件进入 */
  // 语句
}
/* if...else if... */
if(条件1) {
  // 满足条件1执行
} else if(条件2) {
  // 不满足条件1但满足条件2执行
} else if(条件3) {
  // 不满足上面两个条件，但满足条件3执行
} else {
  // 都不满足执行
}
```

#### switch 语句

```js
switch(expresstion) { // 计算值
  case value1:  // 值和这个匹配
    statement;  // 则执行语句
    break;      // 遇到 break 立即结束
  case value2:  // 值和 value1 不匹配，和 value2 匹配
    statement;  // 执行语句，没有遇到 break 则接着往下执行
  case value3:  // 值和 value1、value2 都不匹配
    statement;  // 则执行这条语句
    break;
  default:      // 如果上面的都不匹配
    statement;  // 则执行这条语句
}
```

### 循环语句

#### for 语句

```js
for(let i = 10; i > 0; i--) {
  console.log(i)
}
```

for(初始化; 判断条件; 条件改变)

1. 先执行初始化
2. 判断条件
3. 如果值为 true，则执行花括号内容；否则停止。再执行第四步
4. 条件改变，再进入第二步

#### for-in 语句

一般用来遍历对象，得到下标或属性

```js
let obj = {
  name: 'Tom',
  age: 18,
  sex: 'gendle'
}
for(let key in obj) {
  console.log(`${key}: ${obj[key]}`)
}
```

#### for-of 语句

- 用来遍历可迭代对象（Array、Map、Set、String、arguments）
- 得到每一个值

```js
let str = ''
for(let char of 'hello') {
  str += char + char
}
console.log(str)
```

#### continue 关键字

遇到 continue 就跳过本次循环，进入下次循环

#### break 关键字

遇到 break 立即停止，跳出循环体

#### while 循环

```js
let i = 0
// while(i < 10) { i++ }
while(true) { // 需要设定好条件，否则会死循环
  if(i < 10) {
    break
  }
  i++
}
```

#### do-while 循环

```js
let i = 0
d { // 至少会执行一次
  i++
} while(i<10)
```

> 🌰 计算数组正数平方和

分析：有个数组——>判断是不是正数——>计算每个正数平方相加

```js
let arr = [3, -10, 2, 9, -3, 0, 8]
let squareSum = 0 // 初始化
for(let i = 0; i < arr.length; i++) { // 循环检查每一项
  if(arr[i]<=0) { // 不是正数就跳过本次循环
    continue
  }
  squareSum += arr[i]*arr[i] // 计算平方并每次叠加到 squareSum
}
console.log(squareSum)
```

## 函数

函数是一个能实现特定功能的固定程序段，带有一个入口和一个出口

- 先声明，再调用
- 调用才是真正执行

```js
function sum(val1, val2) { // 声明函数，函数名(形参)
  let re = val1 + val2
  return re // 返回值，如果没有则返回值为 undefined
}
let sum1 = sum(1, 2) //调用函数，获得返回值，并赋值给 sum1
console.log(sum1)
console.log(sum(2, 3)) // 可以多次调用，传入实参
```

### 函数声明方式

方式一：函数声明

```js
function sayHello(name) {
  console.log("Hello " + name)
}
sayHello('Tom')
```

方式二：函数表达式

```js
const sayHello = function(name) {
  console.log("Hello " + name)
}
sayHello('Tom') // 函数调用必须在声明之后
```

### 返回值

- 使用 return 把结果导出
- 函数执行到 return 就**立即终止**，函数后面的代码将不会被执行
- 如果没有设置 return，默认返回的是 undefined

### 箭头函数

- 箭头函数能简化函数表达式
- 如果函数体只有 return，去掉花括号
- 如果参数只有一个，可以把参数小括号去掉

```js
function sum(a, b) { return a + b } // ↓
const sum = function(a, b) { return a + b } // ↓
// 箭头函数，函数体只有 return 可以省去花括号
const sum = (a, b) => a + b
// 有其他内容，花括号不能省
const sum = (a, b) => { console.log(a + b); return a + b; }
// 参数只有一个，可以把参数小括号去掉
const inc = n => ++n
// 如果返回的值是对象，对象必须加小括号
const createPet = name => ({name: name})
/*  */
function sum(a) {
  return function(b) { return a + b }
}
// 可以写成
const sum = a => b => a + b
```

> 🌰 统计字符串中每个字符的出现频率

分析：定义一个字符串、一个存储每个字符数量的变量（对象） → 遍历字符串（for、for-of）→

> 🌰 二进制转为十进制

> 🌰 生成随机 IP 地址

> 🌰 生成随机 rgb、HEX 颜色

> 🌰 打印杨辉三角

## 递归

函数自己调用自己

```js
function fn() {
  fn()
}
fn()
// 自己调用自己，超出了一定次数 RangeError: Maxinum call stack size exceeded
```

🌰 计算阶乘
```js
// n! = n*(n-1)*...*3*2*1
// 正常的写法
function factorial(n) {
  let result = 1
  for(let i = 1; i <= n; i++) {
    result *= i
  }
  return result
}
// 递归写法
// f(n) = n*f(n-1)
function f(n) {
  if(n === 1) return 1 // 需要有退出条件
  return n*f(n-1)
}
```

> 🌰 递归实现斐波那契数列

```js
// F(0)=0, F(1)=1, F(n)=F(n-1)+F(n-2)
function fib(n) {
  if(n === 0) return 0
  if(n === 1) return 1
  return fib(n-1) + fib(n-2)
}
// 即使前面计算了F(3)，它下次遇到了F(3)还是需要计算，性能不好
```

使用场景：
- 不知道具体嵌套层数的时候，例如扫描文件夹、树结构等
- 不考虑性能和算法的时候

## 原始类型和引用类型

### 存储内容不同

栈内存中存储内容不同
- 原始类型存储的是值，复制的是值
- 引用类型存储的是地址，复制的是地址，修改的是地址指向的内容

> 🌰 变量重新复制之后输出什么

```js
// 复制的是值
let a = 3
let b = a
a = 13
console.log(b) // 3
// 复制的是地址
let arr1 = [3, 1, 8]
let arr2 = arr1
arr1[0] = 13
console.log(arr2) // [13, 1, 8]
```

![](https://cdn.wallleap.cn/img/pic/illustration/202303071734561.png)

> 🌰 判断相等

```js
// 原始类型 比较值
let a = "string"
let b = "string"
console.log(a === b) // true
// 引用类型 比较地址，只要是新建的就会生成新的地址
let obj1 = { a: 1, b: 2 }
let obj2 = { a: 1, b: 2 }
let obj3 = obj1
console.log( obj1 === obj2, obj1 === obj3) // false true
console.log( {} === {}, [] === []) // false false 判断数组为空可以使用 arr.length 判断
function sum(a, b) { return a+b }
const sum2 = (a, b) => a+b
let sum3 = sum
console.log( sum2 === sum ) // false
console.log( sum3 === sum ) // true 地址相同
```

### 引用类型和参数传递

函数的形参如果是引用类型（对象、数组、函数...），操作形参的内容就是操作实参的内容

函数的形参如果是原始类型，修改后需要 `return` 出去

```js
// 原始类型作为参数
function inc(n) {
// 等价于 let n = a
  n++
}
let a = 1
inc(a)
console.log(a) // 1
// 修改后 return
function inc1(n) {
  n++
  return n
}
let b = 1
let c = inc1(b)
console.log(c) // 2
// 引用类型作为参数
function incArr(arr) {
// 等价于 let arr = arr1
  arr[0]++
}
let arr1 = [1, 2, 3]
incArr(arr1)
console.log(arr1)  // [2, 2, 3]
```