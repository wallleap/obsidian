---
title: 009-JS 类型的基本使用
date: 2023-02-28 17:07
updated: 2023-03-01 17:34
cover: //cdn.wallleap.cn/img/post/1.jpg
image-auto-upload: true
author: Luwang
comments: true
aliases:
  - 009-JS 类型的基本使用
rating: 1
tags:
  - JavaScript
category: web
keywords:
  - 关键词1
  - 关键词2
  - 关键词3
description: 文章描述
source: null
url: //myblog.wallleap.cn/post/1
---

## 数字和字符串

### 数字的日常用法

- `parseInt(string[, radix])`
	- 把第一个参数转换为字符串，并对字符串进行解析，返回一个整数或 `NaN`
	- 第一个参数是字符串，如果不是会先使用 `toString` 转为字符串，开头空白字符会被忽略
	- 第二个参数可选，是 `2` 到 `36` 的整数，表示进制的基数
	- 默认是返回一个十进制数，指定了进制的话（第二参数）那么会按照这个进制转换成十进制整数
	- 如果只有数字的话建议不加引号，其他进制数一样 如 `0o11`、`0b11`、`0x11`，写的这种形式会按照推断进行转换为十进制
	- 如果加了引号，只会识别前面的数字，后面的字母会截断，例如 `11x00` 返回 `11`，如果字母开头那输出 `NaN`
	- 第二个参数不指定或指定为 `0` 是自己推断，如果不是 `0` 或 `2` 到 `36` 的数会返回 `NaN`
- `parseFloat(string)`
	- 返回一个浮点数或 `NaN`
	- 如果参数对象里有 toString 或 valueOf 方法，会返回他们的返回值

```js
parseInt('100')  // 转为数字
parseInt('100', 2)  // 第二个参数是进制，以该进制转为十进制数输出
parseInt(15.20)  // 可以去除小数部分
parseInt('ab123')  // 不以数字开头，会输出 NaN
/* 二进制存储数字，所以小数的时候会出现精度问题 */
(0.1+0.2) !== 0.3  // 尽量不用浮点数 例如金额直接用最小单位188888分
parseFloat('3.45')  // 转为浮点数
34.5678.toFixed(2)  // 保留多少位小数（有四舍五入）
```

### 数字的深入了解

```js
num.toPrecision(5)  // 限制整数+小数的总位数
2**53 < 2**53+1  // 返回 false 超出最大范围了
Number.MAX_SAFE_INTEGER // 最大范围
Number.MAX_VALUE // 1.79e+308 最大值 加任意值不会变了
Number.MAX_VALUE * 2 // 乘2会返回 Infinity
// 可以使用大数 100n 本质是字符串运算
10000000000000000000n + 3658n
/* Math 方法 */
Math.abs(-111)  // 绝对值
Math.floor(3.55)  // 3 向下取整
Math.ceil(3.12)  // 4 向上取整
Math.round(1.5)  // 2 四舍五入取整
Math.random()  // 取[0,1)的随机值
Math.floor(Math.random()*100) // [0,100) 的整数
Math.floor(y + Math.random()*(x-y+1)) // [y,x] 的整数
Math.pow(x,y)
x**y  // x 的 y 次方
```

### 字符串表示

可以使用成对的引号包裹

- `'string'`
- `"hello"`

或者使用 "`" 符号包裹

```js
let str = `hello JavaScript`
```

使用 `\` 进行转义

```js
let path = "D:\\Games\\war"
let str1 = "你好啊，这个是 \"引号包裹的内容\" \n我是换行后的内容"
```

模板字符串中变量 `${变量}`

```js
let name = 'luwang', age = 25
console.log("Hello, my name is " + name + ", age " + age + ".") // 字符串拼接
console.log(`Hello, my name is ${name}, age ${age}.`) // 模板字符串
```

### 字符串的访问和拼接

```js
str.length  // 字符串长度
str[0]  // 下标获取字符 str[str.length - 1]
str.charAt(0)
str.charCodeAt(0)  // 获取到的字符的 Unicode 值
str1 + str2
`${str1}${str2}`
str1.concat(str2)
```

### 字符串的查找和截取

```js
str.indexOf('subStr')  // 返回的是数字  -1 代表没找到
str.lastIndexOf(subStr)  // 从后往前找
str.includes(subStr)  // 返回 Boolean false 是没找到
str.startsWith(subStr)
str.endsWith(subStr)
str.substr(1,3)  // 开始位置，和截取的长度
str.substring(1,3)  // 开始位置和结束位置  开头结尾 返回 Boolean
```

### 字符串其他操作

```js
str.split(' ')  // 以什么分开为数组
str.trim()  // 去除两边的空格
str.trimLeft()  // 去除左边的空格
str.toUpperCase()  // 转成大写
str.toLowerCase()  // 转成小写
```

## 数组基础使用

```js
// 定义
let arr = [2, [1, 3]
// 长度
arr.length
arr.length = 0  // 清空数组
// 访问
arr[0]
arr[arr.length -1]
arr[1][1]
arr[arr.length]  // 越界会返回 undefined
arr[arr.length] = 1 // 可以直接赋值  在末尾加1
```

## 对象基础使用

```js
// 定义
// 无序的数据集合，由若干个“键值对”构成
let obj = { str: 'hello', num: 12}
console.log(obj)
// 访问
obj.str
obj['str']
let key = 'str'
obj[key] // 可以给变量 就不用加引号了（变量只能用方括号，不能用点访问对象属性）
obj['key']  // 没有会返回 undefined
obj.bool  // 不存在的属性 undefined
// 可以直接修改属性
obj.num = 18
```

## 流程控制语句

### 条件判断语句

#### if 语句

```js
/* 判断 */
if(条件) { /* 条件满足进入 */
  // 语句
}
/* if...else */
if(条件) { /* 满足条件进入 */
  // 语句
} else { /* 不满足条件进入 */
  // 语句
}
/* if...else if... */
if(条件1) {
  // 满足条件1执行
} else if(条件2) {
  // 不满足条件1但满足条件2执行
} else if(条件3) {
  // 不满足上面两个条件，但满足条件3执行
} else {
  // 都不满足执行
}
```

#### switch 语句

```js
switch(expresstion) { // 计算值
  case value1:  // 值和这个匹配
    statement;  // 则执行语句
    break;      // 遇到 break 立即结束
  case value2:  // 值和 value1 不匹配，和 value2 匹配
    statement;  // 执行语句，没有遇到 break 则接着往下执行
  case value3:  // 值和 value1、value2 都不匹配
    statement;  // 则执行这条语句
    break;
  default:      // 如果上面的都不匹配
    statement;  // 则执行这条语句
}
```

### 循环语句

#### for 语句

```js
for(let i = 10; i > 0; i--) {
  console.log(i)
}
```

for(初始化; 判断条件; 条件改变)

1. 先执行初始化
2. 判断条件
3. 如果值为 true，则执行花括号内容；否则停止。再执行第四步
4. 条件改变，再进入第二步

#### for-in 语句

一般用来遍历对象，得到下标或属性

```js
let obj = {
  name: 'Tom',
  age: 18,
  sex: 'gendle'
}
for(let key in obj) {
  console.log(`${key}: ${obj[key]}`)
}
```

#### for-of 语句

- 用来遍历可迭代对象（Array、Map、Set、String、arguments）
- 得到每一个值

```js
let str = ''
for(let char of 'hello') {
  str += char + char
}
console.log(str)
```

#### continue 关键字

遇到 continue 就跳过本次循环，进入下次循环

#### break 关键字

遇到 break 立即停止，跳出循环体

#### while 循环

```js
let i = 0
// while(i < 10) { i++ }
while(true) { // 需要设定好条件，否则会死循环
  if(i < 10) {
    break
  }
  i++
}
```

#### do-while 循环

```js
let i = 0
d { // 至少会执行一次
  i++
} while(i<10)
```

> 🌰 计算数组正数平方和

分析：有个数组——>判断是不是正数——>计算每个正数平方相加

```js
let arr = [3, -10, 2, 9, -3, 0, 8]
let squareSum = 0 // 初始化
for(let i = 0; i < arr.length; i++) { // 循环检查每一项
  if(arr[i]<=0) { // 不是正数就跳过本次循环
    continue
  }
  squareSum += arr[i]*arr[i] // 计算平方并每次叠加到 squareSum
}
console.log(squareSum)
```

## 函数

函数是一个能实现特定功能的固定程序段，带有一个入口和一个出口

- 先声明，再调用
- 调用才是真正执行

```js
function sum(val1, val2) { // 声明函数，函数名(形参)
  let re = val1 + val2
  return re // 返回值，如果没有则返回值为 undefined
}
let sum1 = sum(1, 2) //调用函数，获得返回值，并赋值给 sum1
console.log(sum1)
console.log(sum(2, 3)) // 可以多次调用，传入实参
```

### 函数声明方式

方式一：函数声明

```js
function sayHello(name) {
  console.log("Hello " + name)
}
sayHello('Tom')
```

方式二：函数表达式

```js
const sayHello = function(name) {
  console.log("Hello " + name)
}
sayHello('Tom') // 函数调用必须在声明之后
```

### 返回值

- 使用 return 把结果导出
- 函数执行到 return 就**立即终止**，函数后面的代码将不会被执行
- 如果没有设置 return，默认返回的是 undefined

### 箭头函数

- 箭头函数能简化函数表达式
- 如果函数体只有 return，去掉花括号
- 如果参数只有一个，可以把参数小括号去掉

```js
function sum(a, b) { return a + b } // ↓
const sum = function(a, b) { return a + b } // ↓
// 箭头函数，函数体只有 return 可以省去花括号
const sum = (a, b) => a + b
// 有其他内容，花括号不能省
const sum = (a, b) => { console.log(a + b); return a + b; }
// 参数只有一个，可以把参数小括号去掉
const inc = n => ++n
// 如果返回的值是对象，对象必须加小括号
const createPet = name => ({name: name})
/*  */
function sum(a) {
  return function(b) { return a + b }
}
// 可以写成
const sum = a => b => a + b
```

> 🌰 统计字符串中每个字符的出现频率

分析：定义一个字符串、一个存储每个字符数量的变量（对象） → 遍历字符串（for、for-of）→

> 🌰 二进制转为十进制

> 🌰 生成随机 IP 地址

> 🌰 生成随机 rgb、HEX 颜色

> 🌰 打印杨辉三角

## 递归

函数自己调用自己

```js
function fn() {
  fn()
}
fn()
// 自己调用自己，超出了一定次数 RangeError: Maxinum call stack size exceeded
```

🌰 计算阶乘
```js
// n! = n*(n-1)*...*3*2*1
// 正常的写法
function factorial(n) {
  let result = 1
  for(let i = 1; i <= n; i++) {
    result *= i
  }
  return result
}
// 递归写法
// f(n) = n*f(n-1)
function f(n) {
  if(n === 1) return 1 // 需要有退出条件
  return n*f(n-1)
}
```

> 🌰 递归实现斐波那契数列

```js
// F(0)=0, F(1)=1, F(n)=F(n-1)+F(n-2)
function fib(n) {
  if(n === 0) return 0
  if(n === 1) return 1
  return fib(n-1) + fib(n-2)
}
// 即使前面计算了F(3)，它下次遇到了F(3)还是需要计算，性能不好
```

使用场景：
- 不知道具体嵌套层数的时候，例如扫描文件夹、树结构等
- 不考虑性能和算法的时候

## 原始类型和引用类型

### 存储内容不同

栈内存中存储内容不同
- 原始类型存储的是值，复制的是值
- 引用类型存储的是地址，复制的是地址，修改的是地址指向的内容

> 🌰 变量重新复制之后输出什么

```js
// 复制的是值
let a = 3
let b = a
a = 13
console.log(b) // 3
// 复制的是地址
let arr1 = [3, 1, 8]
let arr2 = arr1
arr1[0] = 13
console.log(arr2) // [13, 1, 8]
```

![](https://cdn.wallleap.cn/img/pic/illustration/202303071734561.png)

> 🌰 判断相等

```js
// 原始类型 比较值
let a = "string"
let b = "string"
console.log(a === b) // true
// 引用类型 比较地址，只要是新建的就会生成新的地址
let obj1 = { a: 1, b: 2 }
let obj2 = { a: 1, b: 2 }
let obj3 = obj1
console.log( obj1 === obj2, obj1 === obj3) // false true
console.log( {} === {}, [] === []) // false false 判断数组为空可以使用 arr.length 判断
function sum(a, b) { return a+b }
const sum2 = (a, b) => a+b
let sum3 = sum
console.log( sum2 === sum ) // false
console.log( sum3 === sum ) // true 地址相同
```

### 引用类型和参数传递

函数的形参如果是引用类型（对象、数组、函数...），操作形参的内容就是操作实参的内容

函数的形参如果是原始类型，修改后需要 `return` 出去

```js
// 原始类型作为参数
function inc(n) {
// 等价于 let n = a
  n++
}
let a = 1
inc(a)
console.log(a) // 1
// 修改后 return
function inc1(n) {
  n++
  return n
}
let b = 1
let c = inc1(b)
console.log(c) // 2
// 引用类型作为参数
function incArr(arr) {
// 等价于 let arr = arr1
  arr[0]++
}
let arr1 = [1, 2, 3]
incArr(arr1)
console.log(arr1)  // [2, 2, 3]
```

## 块级作用域

```js
var a = 1
let b = 2
// while、for、while {...}
if(true) {
  var a = 11
  let b = 22
}
console.log(a, b) // 11 2
```

let、const 存在块级作用域，var 没有块级作用域

这些是块：
```js
if() {...} else {...}
for() {...}
while() {...}
do{...} while()
{...}
```

## 声明变量

var、let、const 区别

### var 是 ES3 定义变量的方式（会有遗留的缺陷）

```js
console.log(a, b)
var b = 2
console.log(b)
var a = 1
console.log(a+b)
```

在作用域内声明前置，上面代码过程会是这样的

```js
// 在进入文件时先声明前置，这时是 undefined
var b
var a
// 继续执行代码
console.log(a, b) // undefined undefined
b = 2
console.log(b) // 2
a = 1
console.log(a+b) // 3
```

可重复声明

```js
var a = 1
var a
var a = 3
console.log(a) // 3
// ↓ 声明前置
var a
var a
var a
a = 1
a = 3
```

没有块级作用域

```js
a = 3
var a
{
  var a = 2
}
console.log(a) // 2
```

### let 和 const 是 ES6 定义变量的方式

#### let

先声明再使用（无声明前置）

```js
let a = 2
console.log(a) // 2
console.log(b) // error ReferenceError: Cannot access 'b' before initialization
let b
b = 'str'
```

不可重复声明

```js
let a
let a = 2 // error SyntaxError: Identifier 'a' has already been declared
```

有块级作用域

```js
let a
{
  let a = 2
  console.log(a) // 2
}
console.log(a) // undefined
```

#### const 相当于声明常量

同 let 上面的

声明时需要立即初始化

```js
const URL
URL = "api.github.com" // SyntaxError: Missing initializer in const declaration
```

初始化后不能再修改

```js
const URL = 'https://wallleap.cn'
URL = "api.github.com" // TypeError: Assignment to constant variable.
```

不变的是 const 声明变量内的内容，对于**引用类型**，存储的是地址，只要地址没变，值改变对象里面的属性就不会报错（再有重新赋值这个操作就会报错）

```js
const a = 1
a = 2 // TypeError: Assignment to constant variable.
a = 1 // TypeError: Assignment to constant variable.
const obj1 = {}
obj1 = {} // TypeError: Assignment to constant variable.
const arr1 = []
arr1 = [] // TypeError: Assignment to constant variable.
arr1 = arr1 // TypeError: Assignment to constant variable.
// 没有修改存储的内容
const obj = { name: 'wallleap' }
obj.name = 'luwang'
console.log(obj) // [object Object] { name: "luwang" }
const arr = [1, 2, 3]
arr[arr.length] = 4
console.log(arr) // [1, 2, 3, 4]
```

> 补充：EcmaScript 不涉及到宿主对象，最开始版本 ES 3，ES 4 没成形，ES 5、ES 6 → ES 2015  ES 2016  ES 2017 ...
>  可以运行在浏览器（DOM BOM）Node.js 单片机内

## var 和 function 的声明前置

```js
a = 3
console.log(a) // 3
var a

function fn() {
  console.log(b)
  var b = 10
  console.log(b)
}
fn() // undefined 10

// 等价于 ↓
var a
function fn() {
  var b
  console.log(b)
  b = 10
  console.log(b)
}
a = 3
console.log(a)
fn()
```

> var 是糟粕，建议用 let 和 const 取代

```js
var fn3
fn()  // 函数声明
function fn() {
  console.log('函数声明')
}
fn2() // ReferenceError: Cannot access 'fn2' before initialization
const fn2 = function() {
  console.log('函数表达式')
}
fn3() // TypeError: fn3 is not a function
fn3 = function() {
  console.log('var')
}
```

函数声明可以写在前面，因为会声明前置；但是函数表达式不可以

## 词法作用域、作用域链

### 作用域

作用域是值和表达式能**被访问**的**执行上下文**

如果值和表达式不在当前作用域，就无法访问

```js
// fn 中没有 a，外面也没有 a
function fn() {
  console.log(a)
}
fn()  // ReferenceError: a is not defined
// fn 中有 a，全局没有 a，外面访问不到函数作用域内的 a
function fn1() {
  let a = 1
  console.log(a)
}
fn1()  // 1
console.log(a)  // ReferenceError: a is not defined
```

作用域有层级，子作用域可以访问祖先作用域变量

```js
// 里面没有 a，一层层往外面找
let a = 1
function fn() {
  console.log(a)
}
fn()  // 1
```

作用域种类
- 全局作用域
- 函数作用域
- 块级作用域（花括号创建的）
- 模块作用域（模块模式下的）

### 词法作用域

创建函数所在的作用域

```js
/* 首先是声明前置，然后才是运行函数 */
function foo() {  // 在全局创建的函数，所以词法作用域就是全局，下面的 bar 也一样
  console.log('foo')
  bar()  // 内部找不到，到词法作用域中找
}
function bar() {
  console.log('bar')
}
foo()
```

### 作用域链

- 当需要访问某个变量时，先从**自己作用域**查找（找自己作用域声明的变量、形参）
- 如果找不到，再从**创建**当前函数所在的作用域（词法作用域）去找，以此往上，**直到全局作用域**

```js
let a = 0
function foo() {
  let a = 1
  bar()
}
function bar() {
  console.log(a)
}
foo() // 0
/**
* 首先声明前置
* 然后 let a = 0
* 接着 执行 foo
* 进入 foo
* 执行 bar，此时内部找不到 bar，会到 foo 的词法作用域找（即全局）
* 找到了 bar，接着执行，进入 bar，发现有 a，bar 的作用域中没发现 a
* 此时到 bar 的词法作用域找（即全局），找到了 a 是 0
*/
let a = 0
function foo() {
  let a = 1
  bar()
  function bar() {
    console.log(a)
  }
}
foo()  // 1
/**
* 首先声明前置 function foo() { ... }
* let a = 0
* 调用 foo
* 进入 foo，声明前置，function bar() { ... }
* let a = 1
* 调用 bar，当前作用域有 bar，直接执行
* 发现有 a，但是 bar 函数作用域内没有 a，先往 bar 词法作用域找
* 发现 foo 函数作用域有 a，所以就是 1
*/
```

### TDZ

const 和 let 变量在**当前作用域**的**开头到当前声明**该变量的区域属于暂时性死区，不可访问该变量

如果出现 var，需关注 var 声明前置

```js
let a = 0
function fn() {
  a = 2
}
fn()
console.log(a)  // 2
let b = 1
function fn1() {
  b = 2
  let b // 从开头到这里都是 TDZ
}
fn1()
console.log(b)  // ReferenceError: Cannot access 'b' before initialization
```

再看个例子 🌰

```js
let a = 0
function foo() {
  bar()
  var a = 1  // 声明前置
  function bar() {
    console.log(a)
  }
}
foo()  // undefined
let b = 0
function fn() {
  f()
  let a = 1  // TDZ
  function f() {
    console.log(a)
  }
}
fn()  // ReferenceError: Cannot access 'a' before initialization
```

例子2 🌰

```js
var a = 1
function fn1() {
  function fn2() {
    console.log(a)
  }
  function fn3() {
    var a = 4
    fn2()
  }
  var a = 2
  return fn3
}
var fn = fn1()
fn()
/* 改造 ↓ */
var a
var fn
function fn1() {
  var a
  function fn2() { ... }
  function fn3() { ... }
  a = 2
  return fn3
}
a = 1
fn = fn1()
fn()   // ← 这里才正式开始执行 fn1()() → fn3()
/*
* var a
* a = 4
* fn2() → console.log(a) 这个是 fn2 里的，它作用域中没 a
* 找创建 fn2 的作用域，即 fn1 函数作用域，有 a 且声明前置了，fn2 是在 fn3 中调用的，fn3 的调用是在 a = 2 下面的，所以值为 2
*/
```


